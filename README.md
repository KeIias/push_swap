# push_swap
This is a project in which you're given a stack of numbers that you have to sort.
For that purpose, you have a limited selection of moves that are usable as well as two stacks (A and B) than you can use.

The goal is to try to use as few moves as possible, the number of data accesses doesn't matter which constitutes the originality of this exercise.

My own solution uses the Radix algorithm while considering the numbers as binary.

## Available moves
* **sa (swap a)** - swap the first 2 elements at the top of stack a. Do nothing if there
is only one or no elements).

* **sb (swap b)** - swap the first 2 elements at the top of stack b. Do nothing if there
is only one or no elements).

* **ss** - sa and sb at the same time.

* **pa (push a)** - take the first element at the top of b and put it at the top of a. Do
nothing if b is empty.

* **pb (push b)** - take the first element at the top of a and put it at the top of b. Do
nothing if a is empty.

* **ra (rotate a)** - shift up all elements of stack a by 1. The first element becomes
the last one.

* **rb (rotate b)** - shift up all elements of stack b by 1. The first element becomes
the last one.

* **rr** - ra and rb at the same time.

* **rra (reverse rotate a)** - shift down all elements of stack a by 1. The last element
becomes the first one.

* **rrb (reverse rotate b)** - shift down all elements of stack b by 1. The last element
becomes the first one.

* **rrr** - rra and rrb at the same time.

## Usage
There are 2 programs generated by the Makefile: checker and push_swap; 
push_swap creates a solution from the stack of numbers that's passed as arguments and checker verifies that the provided solution actually sorts the numbers.

```shell
$> git clone https://github.com/Kelias-42/push_swap.git
$> cd push_swap
$> git submodule init
$> git submodule update
$> make
```
