# push_swap
This is a project in which you're given a stack of numbers that you have to sort.
For that purpose, you have a limited selection of moves that are usable as well as two stacks (A and B) than you can use.

The goal is to try to use as few moves as possible, the number of data accesses doesn't matter which constitutes the originality of this exercise.

My own solution uses the Radix algorithm while considering the numbers as binary.

## Available moves
* **sa (swap a)** - swap the first 2 elements at the top of stack a. Do nothing if there
is only one or no elements).

* **sb (swap b)** - swap the first 2 elements at the top of stack b. Do nothing if there
is only one or no elements).

* **ss** - sa and sb at the same time.

* **pa (push a)** - take the first element at the top of b and put it at the top of a. Do
nothing if b is empty.

* **pb (push b)** - take the first element at the top of a and put it at the top of b. Do
nothing if a is empty.

* **ra (rotate a)** - shift up all elements of stack a by 1. The first element becomes
the last one.

* **rb (rotate b)** - shift up all elements of stack b by 1. The first element becomes
the last one.

* **rr** - ra and rb at the same time.

* **rra (reverse rotate a)** - shift down all elements of stack a by 1. The last element
becomes the first one.

* **rrb (reverse rotate b)** - shift down all elements of stack b by 1. The last element
becomes the first one.

* **rrr** - rra and rrb at the same time.

## Usage
There are 2 programs generated by the Makefile: checker and push_swap; 
push_swap creates a solution from the stack of numbers that's passed as arguments and checker verifies that the provided solution actually sorts the numbers.

```shell
$> git clone https://github.com/Kelias-42/push_swap.git
$> cd push_swap
$> git submodule init
$> git submodule update
$> make
```
You can then use push_swap followed by as much numbers as you want as arguments which will constitute the stack to sort. You will then have the list of moves to do in order to solve it.

The checker program takes a stack in the same way as push_swap in arguments. It will then ask for operations in the standard output which will be applied to the stack. Once you close the standard output, checker will tell you if those operations solved the stack or not.

Those programs were built to work with each other, meaning that if you execute: 
```shell
./push_swap [your number stack] | ./checker [same number stack] 
```
OK will be printed if the algorithm managed to sort your stack.
